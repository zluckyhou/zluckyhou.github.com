---
layout: post
title: 跟老齐学python
date: 2016-6-20
categories: blog
tags: python
description: python 学习总结
---
本文来自[跟老齐学python](https://github.com/qiwsir/StarterLearningPython/blob/master/index.md)，希望从现在开始，重新努力学习python，把这本书中的一些重点积累在这里，一来督促自己学习，二来积攒一些学习的素材和经验。由于是自己学习，本文不会刻意追求排版的优美，只求清晰明了地记录一些自己认为重要的东西。

在此首先表示对老齐的由衷感谢，最近一段时间，我特别觉得，一个人能够把自己努力做出的一些成果无私地分享给其他人，实在是太伟大了，我是打心底里佩服和感谢，希望将来自己也可以通过自己的努力，慢慢地分享一些有用的东西，这是互联网时代，共享让世界更美好！

--------------

# Day 1

----

# 开头

开头的开头，请学会查看官方文档[The Python Tutorial](https://docs.python.org/2/tutorial/index.html)

python应用案例[https://www.python.org/about/success/](https://www.python.org/about/success/)

[编程匠艺训练](http://www.itdiffer.com/coding.html)

[What IDE to use for Python?](http://stackoverflow.com/questions/81584/what-ide-to-use-for-python)

# 第壹章 基本数据类型

## 数
在Python中，每个数字都是真实存在的，相对于我们——人类——来讲，它真实存在，它就是对象（object）。

比如整数3，就是一个对象。

每个对象，在内存中都有自己的一个地址，这个就是它的身份。

用内建函数id()可以查看每个对象的内存地址，即身份。用id()得到的内存地址，是只读的，不能修改。

```
>>> id(3)
140574872
>>> id(3.222222)
140612356
>>> id(3.0)
140612356
>>>

```

了解了“身份”，再来看“类型”，也有一个内建函数供使用type()。

```
>>> type(3)
<type 'int'>
>>> type(3.0)
<type 'float'>
>>> type(3.222222)
<type 'float'>

```

## 变量

在Python中，有这样一句话是非常重要的：**对象有类型，变量无类型**。

在Python中，整数可以无限大，但是，浮点数跟整数不同，它存在上限和下限，如果超出了上下的范围，就会出现溢出问题了。

[整数溢出](http://zhaoweizhuanshuo.blog.163.com/blog/static/148055262201093151439742/)

## 除法

python 2运算

```
>>> 2 / 5
0
>>> 2.0 / 5
0.4
>>> 2 / 5.0
0.4
>>> 2.0 / 5.0
0.4

```

在Python 2里面有一个规定，像2/5中的除法这样，是要取整（就是去掉小数，但不是四舍五入）。2除以5，商是0（整数），余数是2（整数）。那么如果用这种形式：2/5，计算结果就是商那个整数。或者可以理解为：**整数除以整数，结果是整数（商）**。

```
>>> 5 / 2
2
>>> 7 / 2
3
>>> 8 / 2
4

```

在Python 3.x中，规则又变了，如果 1/2 ，结果就是0.5，也就是说Python 3中的除法是真正的除法了，要取整，只能用 1//2 的方式，即 1//2=0 。

不管是Python 2还是Python 3，都有这种情况：

```
>>> 10.0 / 3
3.3333333333333335
>>> 0.1 + 0.2
0.30000000000000004
>>> 0.1 + 0.1 - 0.2
0.0
>>> 0.1 + 0.1 + 0.1 - 0.3
5.551115123125783e-17
>>> 0.1 + 0.1 + 0.1 - 0.2
0.10000000000000003

```

这是因为计算机在计算的时候，首先要把十进制转换成二进制，而转换时会出现近似，从而造成结果不精确，对于一般的情形，我们只需对结果进行四舍五入即可。

但是如果需要精确的结果，那么可以使用 decimal 模块，它实现的十进制运算适合会计方面的应用和高精度要求的应用。

另外 fractions 模块支持另外一种形式的运算，它实现的运算基于有理数（因此像1/3这样的数字可以精确地表示）。

最高要求则可是使用numPy 包和其它用于数学和统计学的包。

### 引用模块解决除法

```
>>> from __future__ import division
>>> 5 / 2
2.5
>>> 9 / 2
4.5
>>> 9.0 / 2
4.5
>>> 9 / 2.0
4.5

```
注意了，引用了一个模块之后，再做除法，就不管什么情况，都是得到浮点数的结果了。

### 余数

在Python中（其实大多数语言也都是），用 `%` 符号来取得两个数相除的余数.

除了使用 `%` 求余数，还有内建函数 `divmod()` ——返回的是商和余数。

要实现四舍五入，很简单，就是内建函数： `round()`，例如`round(1.234567, 2)` 为1.23


## math

import math 引入math模块， dir(module)查看查看模块有哪些方法

第一天就学习到这里，明天继续学习下一节：写一个简单程序

------------

# Day2
------

## 字符串
python如果要用到中文，需要在文件开头添加`#coding:utf-8`

连接字符串，用`+`，python 无法连接不同类型的对象，连接一个int型和一个str型的对象有以下三种方法

```
a=1998
b="hello"

print b+`a` #尽量不用这种方式
print b+ str(a)
or
print b+ repr(a)

```

[python内建函数](https://docs.python.org/2/library/functions.html)

python 中`\``通常被看做转义符，有时候为了使用其原始含义，需要使用转义符，例如

```
>>> dos = "c:\news"
>>> dos
'c:\news'             #这里貌似没有什么问题
>>> print dos    #当用print来打印这个字符串的时候，就出问题了。
c:
ews

```
用转义符可以解决

```
>>> print "c:\\news"
c:\news
or
>>> print r"c:\news"
c:\news
```

`ord()` 是一个内建函数，能够返回某个字符（注意，是一个字符，不是多个字符组成的串）所对一个的ASCII值（是十进制的），字符a在ASCII中的值是97，空格在ASCII中也有值，是32。顺便说明，反过来，根据整数值得到相应字符，可以使用 `chr()` ：


### 字符串格式化

```
>>> print "I like %s" % "python"
I like python
```

`%`现在已经不常用了，现在主要用`.format`,format 是字符串的一个方法，可以在`dir(str)`中查到，format方法的作用可以通过帮助文档`help(str)`来查看

```
>>>help(str.format)
Help on method_descriptor:
format(...)
    S.format(*args, **kwargs) -> string
    
    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').

```

## 坑爹的字符编码

[字符编码](https://github.com/qiwsir/StarterLearningPython/blob/master/110.md)

[字符编码笔记：ASCII，Unicode和UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)

[Unicode.org](http://www.unicode.org/)

[Python2.x的中文显示方法](https://github.com/qiwsir/ITArticles/blob/master/Python/Python%E7%9A%84%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E6%96%B9%E6%B3%95.md)


## 列表——python中的苦力

```
>>> a = ['2', 3, 'qiwsir.github.io']
>>> a
['2', 3, 'qiwsir.github.io']
>>> type(a)
<type 'list'>
>>> bool(a)
True
>>> print a
['2', 3, 'qiwsir.github.io']

```

### 常用的列表函数

两个让列表扩容的函数 append() 和 extend() ，它们的共同点是“都能原地修改列表”。对于“原地修改”还应该增加一个理解——没有返回值。

原地修改没有返回值，就不能赋值给某个变量。

```
>>> one = ["good","good","study"]
>>> another = one.extend(["day","day","up"])    #对于没有提供返回值的函数，如果要这样，结果是：
>>> print anthor                                #打印变量another的值。如果是Python3则输入print(another)
None                                            #返回为None, one.extend()没有返回值，即是None.
>>> one
['good', 'good', 'study', 'day', 'day', 'up']

```

- list.remove(x) 中的参数是列表中元素，即删除某个元素，且对列表原地修改，无返回值
- list.pop([i]) 中的i是列表中元素的索引值，可选。为空则删除列表最后一个，否则删除索引为i的元素。并且将删除元素作为返回值。

### 反转

还是通过举例来演示反转的方法：

```
>>> alst = [1, 2, 3, 4, 5, 6]
>>> alst[: : -1]    #反转
[6, 5, 4, 3, 2, 1]
>>> alst
[1, 2, 3, 4, 5, 6]

```
对于字符串也可以：

```
>>> lang
'python'
>>> lang[::-1]
'nohtyp'
>>> lang
'python'

```

Python还有另外一种方法让列表反转，是比较容易理解和阅读的，特别推荐之：

```
>>> list(reversed(alst))
[6, 5, 4, 3, 2, 1]
>>> list(reversed("abcd"))
['d', 'c', 'b', 'a']

```

```
>>> help(reversed)
Help on class reversed in module __builtin__:

class reversed(object)
 |  reversed(sequence) -> reverse iterator over values of the sequence
 |  
 |  Return a reverse iterator

```

### split and join

**str.split()**

**"[sep]".join(list)**

## 元组


```
>>> t = 123, 'abc', ["come","here"]
>>> t
(123, 'abc', ['come', 'here'])

```
元组中的元素不能更改，这点上跟列表不同，倒是跟str类似；它的元素又可以是任何类型的数据，这点上跟列表相同，但不同于字符串。

**特别提醒**，如果一个元组中只有一个元素的时候，应该在该元素后面加一个半角的英文逗号。

```
>>> a = (3)
>>> type(a)
<type 'int'>

>>> b = (3,)
>>> type(b)
<type 'tuple'>

```

**所有在列表中可以修改列表的方法，在元组中，都失效**。因为元组不可修改。

分别用 list() 和 tuple() 能够实现两者的转化:

```
>>> t = (1, '23', [123, 'abc'], ('python', 'learn'))
>>> tls = list(t)                           #tuple-->list
>>> tls
[1, '23', [123, 'abc'], ('python', 'learn')]

>>> t_tuple = tuple(tls)                    #list-->tuple
>>> t_tuple
(1, '23', [123, 'abc'], ('python', 'learn'))

```
一般认为，元组有这类特点，并且是它使用的情景:

- 元组比列表操作速度快。如果您定义了一个值的常量集，并且唯一要用它做的是不断地遍历它，请使用元组代替列表。

- 如果对不需要修改的数据进行 “写保护”，可以使代码更安全。使用元组而不是列表如同拥有一个隐含的 assert 语句，说明这一数据是常量。如果必须要改变这些值，则需要执行元组到列表的转换 (需要使用一个特殊的函数)。

- 元组可以在字典（又一种对象类型，后面要讲述） 中被用做 key，但是列表不行。字典的key 必须是不可变的。元组本身是不可改变的，列表是可变的。

- 元组可以用在字符串格式化中。

## 字典

字符串格式化输出

这是一个前面已经探讨过的话题，请参看《字符串(4)》，这里再次提到，就是因为用字典也可以实现格式化字符串的目的。

```
>>> city_code = {"suzhou":"0512", "tangshan":"0315", "hangzhou":"0571"}
>>> " Suzhou is a beautiful city, its area code is %(suzhou)s" % city_code
' Suzhou is a beautiful city, its area code is 0512'

```
```
>>> temp = "<html><head><title>%(lang)s<title><body><p>My name is %(name)s.</p></body></head></html>"
>>> my = {"name":"qiwsir", "lang":"python"}
>>> temp % my
'<html><head><title>python<title><body><p>My name is qiwsir.</p></body></head></html>'

```

## 集合

它的特点是：有的可变，有的不可变；元素无次序，不可重复。

**可变的集合**：以`set()`建立的集合可变
**不可变的集合**：以`frozenset()`建立的集合不可变


--------------

# Day 3

-----------------

# 第贰章 语句和文件

**内建函数`zip`**

```
>>> c = [1, 2, 3]
>>> d = [9, 8, 7, 6]
>>> zip(c, d)        #这是Python 2的结果，如果是Python 3，请仿照前面的方式显示查看
[(1, 9), (2, 8), (3, 7)]
or
>>> result = [(2, 11), (4, 13), (6, 15), (8, 17)]
>>> zip(*result)
[(2, 4, 6, 8), (11, 13, 15, 17)]

>>> myinfor = {"name":"qiwsir", "site":"qiwsir.github.io", "lang":"python"}
>>> dict(zip(myinfor.values(), myinfor.keys()))
{'python': 'lang', 'qiwsir.github.io': 'site', 'qiwsir': 'name'}

```
**内建函数`enumerate`**

```
>>> week = ['monday', 'sunday', 'friday']
>>> for i in range(len(week)):
...     print week[i]+' is '+str(i)     #注意，i是int类型，如果和前面的用+连接，必须是str类型
...                                                           #如果使用Python 3，请自行更换为print(week[i]+' is '+str(i))
monday is 0
sunday is 1
friday is 2

```

内建函数enumerate，能够实现类似的功能，并且简化。

```
>>> for (i, day) in enumerate(week):
...     print day+' is '+str(i)        #Python 3: print(day+' is '+str(i))
... 
monday is 0
sunday is 1
friday is 2

```

```
>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]

>>> list(enumerate(seasons, start=1))
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]

```

**神奇的List comprehensions**

```
>>> squares = [x**2 for x in range(1, 10)]
>>> squares
[1, 4, 9, 16, 25, 36, 49, 64, 81]

>>> mybag = [' glass',' apple','green leaf ']   #有的前面有空格，有的后面有空格
>>> [one.strip() for one in mybag]              #去掉元素前后的空格
['glass', 'apple', 'green leaf']

```

```
>>> week = ['monday', 'sunday', 'friday']
>>>[day+' is ' + str(i) for i,day in enumerate(week)]
>>>['monday is 0', 'sunday is 1', 'friday is 2']

```

----------------

# Day 4

---


**while...else**

`while...else` 有点类似 `if ... else` ，只需要一个例子就可以理解。 当然，一遇到 else 了，就意味着已经不在while循环内了。

```
count = 0
while count < 5:
    print count, " is  less than 5"
    count = count + 1
else:
    print count, " is not less than 5"
```

**for...else**

除了有 `while...else` 外，还可以有 `for...else` 。这个循环也通常用在当跳出循环之后要做的事情。

```
# coding=utf-8

from math import sqrt

for n in range(99, 1, -1):
    root = sqrt(n)
    if root == int(root):
        print n
        break

else:
    print "Nothing."
```

## 文件

### 读文件

```
>>> f = open("130.txt")     #打开已经存在的文件
>>> for line in f:
...     print line        #Python 3: print(line)
... 
learn python

http://qiwsir.github.io

qiwsir@gmail.com

```
**声明**：文件130.txt必须在当前目录下，否则需要引用相对路径

在原文中，每行结束有本行结束符号 \n ，表示换行。 print line 或者 print(line) 默认情况下，打印完 line 的对象之后会增加一个 \n 。这样看来，在每行末尾就有两个 \n ，即： \n\n ，于是在打印中就出现了一个空行。print 后面加个`,`就可以去掉空格

```
>>> f = open('130.txt')
>>> for line in f:
...     print line,        #Python 3: print(line, end='')
... 
learn python
http://qiwsir.github.io
qiwsir@gmail.com

```
**创建文件**

```
>>> nf = open("131.txt", "w") # w表示以写方式打开文件，可向文件写入信息。如文件存在，则清空该文件，再写入新内容
>>> nf.write("This is a file")
>>> nf.close() #记得每次写完之后都要关闭文件

```

在对文件进行写入操作之后，一定要牢记一个事情： `file.close()` ，这个操作千万不要忘记

有另外一种方法，能够不用这么让人揪心，实现安全地关闭文件。

```
>>> with open("130.txt","a") as f: # a表示以追加模式打开文件（即一打开文件，文件指针自动移到文件末尾），如果文件不存在则创建
...     f.write("\nThis is about 'with...as...'")
... 
>>> with open("130.txt","r") as f:
...     print f.read()
... 
learn python
http://qiwsir.github.io
qiwsir@gmail.com
hello

This is about 'with...as...'
>>> 

```
用 open() 操作文件，可以有不同的模式。

模式  |描述
---  |------------
r|以读方式打开文件，可读取文件信息。
w|以写方式打开文件，可向文件写入信息。如文件存在，则清空该文件，再写入新内容
a|以追加模式打开文件（即一打开文件，文件指针自动移到文件末尾），如果文件不存在则创建
r+| 以读写方式打开文件，可对文件进行读和写操作。 
w+ |消除文件内容，然后以读写方式打开文件。 
a+ |以读写方式打开文件，并把文件指针移到文件尾。 
b |以二进制模式打开文件，而不是以文本模式。该模式只对Windows或Dos有效，类Unix的文件是用二进制模式进行操作的。 










