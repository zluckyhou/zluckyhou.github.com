---
layout: post
title: python 继续
date: 2016-9-5
categories: blog
tags: [python]
description: 廖雪峰的python教程
---

学习了[跟老齐学python](https://github.com/qiwsir/StarterLearningPython/blob/master/index.md)，一些基础的知识是掌握了，接下来继续深入学习，[廖雪峰的python教程](http://www.liaoxuefeng.com/)中有一些相对高级一点的内容，包括**面向对象编程**、**进程和线程**、**电子邮件**、**web开发**等，在现有的基础上学习这些知识，我觉得刚刚好。



------------------------------

# day1 函数式编程——2016.9.5 

## 收集参数 * and **

当函数的参数个数不确定时，其它参数全部通过`*arg`，以元组的形式由`arg`收集起来，例子如下：


```
def func(x, *arg):
    print x         #Python 3请自动修改为print()的格式，下同，从略。
    result = x
    print arg       #输出通过*arg方式得到的值
    for i in arg:
        result +=i
    return result

print func(1, 2, 3, 4, 5, 6, 7, 8, 9)    #赋给函数的参数个数不仅仅是2个

```

运行结果：

```
1                       #这是函数体内的第一个print，参数x得到的值是1
(2, 3, 4, 5, 6, 7, 8, 9) #这是函数内的第二个print，参数arg得到的是一个元组
45                      #最后的计算结果

```

上面的例子中：

- 值1传给了x

- 值2,3,4,5,6,7,8,9被塞入一个元组里面，传给了`arg`

除了用*args这种形式的参数接收多个值之外，还可以用**kargs的形式接收数值，例如：

```
>>> def foo(**kargs):
...     print kargs        #Python 3:  print(kargs)
...
>>> foo(a=1,b=2,c=3)    #注意观察这次赋值的方式和打印的结果
{'a': 1, 'c': 3, 'b': 2}

```

如果用**kargs的形式收集值，会得到dict类型的数据，但是，需要在传值的时候说明“键”和“值”，因为在字典中是以键值对形式出现的。

综合以上方法，对于不确定参数个数的函数：

```
>>> def foo(x,y,z,*args,**kargs):
...     print x       #Python 3用户请修改为print()格式，下同
...     print y
...     print z
...     print args
...     print kargs        
... 
  #结果
>>> foo(1,2,3,4,5,name="qiwsir")
1
2
3
(4, 5)
{'name': 'qiwsir'}

```

## 返回函数

对于通常的函数，都会返回结果，例如：

```
def calc_sum(*args):
    s = 0
    for x in args:
        s +=x
    return s


calc_sum(1,2,3,4,5)
Out[17]: 15

```

但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！

```
def lazy_sum(*args):
    def sum():
        s = 0
        for x in args:
            s += x
        return s
    return sum


f = lazy_sum(1,2,3,4,5)

f
Out[20]: <function __main__.sum>

f()
Out[21]: 15

```

## 闭包

一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了`f()`才执行。我们来看一个例子：

```
def count():
    fs = []
    for i in range(1,4):
        def f():
            return i*i
        fs.append(f)
    return fs


f1,f2,f3 = count()

f1
Out[25]: <function __main__.f>

f1(),f2(),f3()
Out[27]: (9, 9, 9)

```

你可能认为调用`f1()`，`f2()`和`f3()`结果应该是`1`，`4`，`9`，但实际结果都是`9`,原因就在于返回的函数引用了变量`i`，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量`i`已经变成了`3`，因此最终结果为`9`。


如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：

```
def count():
    fs = []
    for i in range(1,4):
        def f(j):
            def g():
                return j*j
            return g
        fs.append(f(i))
    return fs


f1,f2,f3 = count()

f1()
Out[30]: 1

f2()
Out[31]: 4

f3()
Out[32]: 9
```


## 装饰器










