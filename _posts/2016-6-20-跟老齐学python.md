---
layout: post
title: 跟老齐学python
date: 2016-6-20
categories: blog
tags: python
description: python 学习总结
---
本文来自[跟老齐学python](https://github.com/qiwsir/StarterLearningPython/blob/master/index.md)，希望从现在开始，重新努力学习python，把这本书中的一些重点积累在这里，一来督促自己学习，二来积攒一些学习的素材和经验。由于是自己学习，本文不会刻意追求排版的优美，只求清晰明了地记录一些自己认为重要的东西。

在此首先表示对老齐的由衷感谢，最近一段时间，我特别觉得，一个人能够把自己努力做出的一些成果无私地分享给其他人，实在是太伟大了，我是打心底里佩服和感谢，希望将来自己也可以通过自己的努力，慢慢地分享一些有用的东西，这是互联网时代，共享让世界更美好！

--------------

# Day 1

----

# 开头

开头的开头，请学会查看官方文档[The Python Tutorial](https://docs.python.org/2/tutorial/index.html)

python应用案例[https://www.python.org/about/success/](https://www.python.org/about/success/)

[编程匠艺训练](http://www.itdiffer.com/coding.html)

[What IDE to use for Python?](http://stackoverflow.com/questions/81584/what-ide-to-use-for-python)

# 第壹章 基本数据类型

## 数
在Python中，每个数字都是真实存在的，相对于我们——人类——来讲，它真实存在，它就是对象（object）。

比如整数3，就是一个对象。

每个对象，在内存中都有自己的一个地址，这个就是它的身份。

用内建函数id()可以查看每个对象的内存地址，即身份。用id()得到的内存地址，是只读的，不能修改。

```
>>> id(3)
140574872
>>> id(3.222222)
140612356
>>> id(3.0)
140612356
>>>

```

了解了“身份”，再来看“类型”，也有一个内建函数供使用type()。

```
>>> type(3)
<type 'int'>
>>> type(3.0)
<type 'float'>
>>> type(3.222222)
<type 'float'>

```

## 变量

在Python中，有这样一句话是非常重要的：**对象有类型，变量无类型**。

在Python中，整数可以无限大，但是，浮点数跟整数不同，它存在上限和下限，如果超出了上下的范围，就会出现溢出问题了。

[整数溢出](http://zhaoweizhuanshuo.blog.163.com/blog/static/148055262201093151439742/)

## 除法

python 2运算

```
>>> 2 / 5
0
>>> 2.0 / 5
0.4
>>> 2 / 5.0
0.4
>>> 2.0 / 5.0
0.4

```

在Python 2里面有一个规定，像2/5中的除法这样，是要取整（就是去掉小数，但不是四舍五入）。2除以5，商是0（整数），余数是2（整数）。那么如果用这种形式：2/5，计算结果就是商那个整数。或者可以理解为：**整数除以整数，结果是整数（商）**。

```
>>> 5 / 2
2
>>> 7 / 2
3
>>> 8 / 2
4

```

在Python 3.x中，规则又变了，如果 1/2 ，结果就是0.5，也就是说Python 3中的除法是真正的除法了，要取整，只能用 1//2 的方式，即 1//2=0 。

不管是Python 2还是Python 3，都有这种情况：

```
>>> 10.0 / 3
3.3333333333333335
>>> 0.1 + 0.2
0.30000000000000004
>>> 0.1 + 0.1 - 0.2
0.0
>>> 0.1 + 0.1 + 0.1 - 0.3
5.551115123125783e-17
>>> 0.1 + 0.1 + 0.1 - 0.2
0.10000000000000003

```

这是因为计算机在计算的时候，首先要把十进制转换成二进制，而转换时会出现近似，从而造成结果不精确，对于一般的情形，我们只需对结果进行四舍五入即可。

但是如果需要精确的结果，那么可以使用 decimal 模块，它实现的十进制运算适合会计方面的应用和高精度要求的应用。

另外 fractions 模块支持另外一种形式的运算，它实现的运算基于有理数（因此像1/3这样的数字可以精确地表示）。

最高要求则可是使用numPy 包和其它用于数学和统计学的包。

### 引用模块解决除法

```
>>> from __future__ import division
>>> 5 / 2
2.5
>>> 9 / 2
4.5
>>> 9.0 / 2
4.5
>>> 9 / 2.0
4.5

```
注意了，引用了一个模块之后，再做除法，就不管什么情况，都是得到浮点数的结果了。

### 余数

在Python中（其实大多数语言也都是），用 `%` 符号来取得两个数相除的余数.

除了使用 `%` 求余数，还有内建函数 `divmod()` ——返回的是商和余数。

要实现四舍五入，很简单，就是内建函数： `round()`，例如`round(1.234567, 2)` 为1.23


## math

import math 引入math模块， dir(module)查看查看模块有哪些方法

第一天就学习到这里，明天继续学习下一节：写一个简单程序

------------

# Day2
------

## 字符串
python如果要用到中文，需要在文件开头添加`#coding:utf-8`

连接字符串，用`+`，python 无法连接不同类型的对象，连接一个int型和一个str型的对象有以下三种方法

```
a=1998
b="hello"

print b+`a` #尽量不用这种方式
print b+ str(a)
or
print b+ repr(a)

```

[python内建函数](https://docs.python.org/2/library/functions.html)

python 中`\``通常被看做转义符，有时候为了使用其原始含义，需要使用转义符，例如

```
>>> dos = "c:\news"
>>> dos
'c:\news'             #这里貌似没有什么问题
>>> print dos    #当用print来打印这个字符串的时候，就出问题了。
c:
ews

```
用转义符可以解决

```
>>> print "c:\\news"
c:\news
or
>>> print r"c:\news"
c:\news
```

`ord()` 是一个内建函数，能够返回某个字符（注意，是一个字符，不是多个字符组成的串）所对一个的ASCII值（是十进制的），字符a在ASCII中的值是97，空格在ASCII中也有值，是32。顺便说明，反过来，根据整数值得到相应字符，可以使用 `chr()` ：


### 字符串格式化

```
>>> print "I like %s" % "python"
I like python
```

`%`现在已经不常用了，现在主要用`.format`,format 是字符串的一个方法，可以在`dir(str)`中查到，format方法的作用可以通过帮助文档`help(str)`来查看

```
>>>help(str.format)
Help on method_descriptor:
format(...)
    S.format(*args, **kwargs) -> string
    
    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').

```

## 坑爹的字符编码

[字符编码](https://github.com/qiwsir/StarterLearningPython/blob/master/110.md)

[字符编码笔记：ASCII，Unicode和UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)

[Unicode.org](http://www.unicode.org/)

[Python2.x的中文显示方法](https://github.com/qiwsir/ITArticles/blob/master/Python/Python%E7%9A%84%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E6%96%B9%E6%B3%95.md)


## 列表——python中的苦力

```
>>> a = ['2', 3, 'qiwsir.github.io']
>>> a
['2', 3, 'qiwsir.github.io']
>>> type(a)
<type 'list'>
>>> bool(a)
True
>>> print a
['2', 3, 'qiwsir.github.io']

```

### 常用的列表函数

两个让列表扩容的函数 append() 和 extend() ，它们的共同点是“都能原地修改列表”。对于“原地修改”还应该增加一个理解——没有返回值。

原地修改没有返回值，就不能赋值给某个变量。

```
>>> one = ["good","good","study"]
>>> another = one.extend(["day","day","up"])    #对于没有提供返回值的函数，如果要这样，结果是：
>>> print anthor                                #打印变量another的值。如果是Python3则输入print(another)
None                                            #返回为None, one.extend()没有返回值，即是None.
>>> one
['good', 'good', 'study', 'day', 'day', 'up']

```

- list.remove(x) 中的参数是列表中元素，即删除某个元素，且对列表原地修改，无返回值
- list.pop([i]) 中的i是列表中元素的索引值，可选。为空则删除列表最后一个，否则删除索引为i的元素。并且将删除元素作为返回值。

### 反转

还是通过举例来演示反转的方法：

```
>>> alst = [1, 2, 3, 4, 5, 6]
>>> alst[: : -1]    #反转
[6, 5, 4, 3, 2, 1]
>>> alst
[1, 2, 3, 4, 5, 6]

```
对于字符串也可以：

```
>>> lang
'python'
>>> lang[::-1]
'nohtyp'
>>> lang
'python'

```

Python还有另外一种方法让列表反转，是比较容易理解和阅读的，特别推荐之：

```
>>> list(reversed(alst))
[6, 5, 4, 3, 2, 1]
>>> list(reversed("abcd"))
['d', 'c', 'b', 'a']

```

```
>>> help(reversed)
Help on class reversed in module __builtin__:

class reversed(object)
 |  reversed(sequence) -> reverse iterator over values of the sequence
 |  
 |  Return a reverse iterator

```

### split and join

**str.split()**

**"[sep]".join(list)**

## 元组


```
>>> t = 123, 'abc', ["come","here"]
>>> t
(123, 'abc', ['come', 'here'])

```
元组中的元素不能更改，这点上跟列表不同，倒是跟str类似；它的元素又可以是任何类型的数据，这点上跟列表相同，但不同于字符串。

**特别提醒**，如果一个元组中只有一个元素的时候，应该在该元素后面加一个半角的英文逗号。

```
>>> a = (3)
>>> type(a)
<type 'int'>

>>> b = (3,)
>>> type(b)
<type 'tuple'>

```

**所有在列表中可以修改列表的方法，在元组中，都失效**。因为元组不可修改。

分别用 list() 和 tuple() 能够实现两者的转化:

```
>>> t = (1, '23', [123, 'abc'], ('python', 'learn'))
>>> tls = list(t)                           #tuple-->list
>>> tls
[1, '23', [123, 'abc'], ('python', 'learn')]

>>> t_tuple = tuple(tls)                    #list-->tuple
>>> t_tuple
(1, '23', [123, 'abc'], ('python', 'learn'))

```
一般认为，元组有这类特点，并且是它使用的情景:

- 元组比列表操作速度快。如果您定义了一个值的常量集，并且唯一要用它做的是不断地遍历它，请使用元组代替列表。

- 如果对不需要修改的数据进行 “写保护”，可以使代码更安全。使用元组而不是列表如同拥有一个隐含的 assert 语句，说明这一数据是常量。如果必须要改变这些值，则需要执行元组到列表的转换 (需要使用一个特殊的函数)。

- 元组可以在字典（又一种对象类型，后面要讲述） 中被用做 key，但是列表不行。字典的key 必须是不可变的。元组本身是不可改变的，列表是可变的。

- 元组可以用在字符串格式化中。

## 字典

字符串格式化输出

这是一个前面已经探讨过的话题，请参看《字符串(4)》，这里再次提到，就是因为用字典也可以实现格式化字符串的目的。

```
>>> city_code = {"suzhou":"0512", "tangshan":"0315", "hangzhou":"0571"}
>>> " Suzhou is a beautiful city, its area code is %(suzhou)s" % city_code
' Suzhou is a beautiful city, its area code is 0512'

```
```
>>> temp = "<html><head><title>%(lang)s<title><body><p>My name is %(name)s.</p></body></head></html>"
>>> my = {"name":"qiwsir", "lang":"python"}
>>> temp % my
'<html><head><title>python<title><body><p>My name is qiwsir.</p></body></head></html>'

```

## 集合

它的特点是：有的可变，有的不可变；元素无次序，不可重复。

**可变的集合**：以`set()`建立的集合可变
**不可变的集合**：以`frozenset()`建立的集合不可变


--------------

# Day 3

-----------------

# 第贰章 语句和文件

**内建函数`zip`**

```
>>> c = [1, 2, 3]
>>> d = [9, 8, 7, 6]
>>> zip(c, d)        #这是Python 2的结果，如果是Python 3，请仿照前面的方式显示查看
[(1, 9), (2, 8), (3, 7)]
or
>>> result = [(2, 11), (4, 13), (6, 15), (8, 17)]
>>> zip(*result)
[(2, 4, 6, 8), (11, 13, 15, 17)]

>>> myinfor = {"name":"qiwsir", "site":"qiwsir.github.io", "lang":"python"}
>>> dict(zip(myinfor.values(), myinfor.keys()))
{'python': 'lang', 'qiwsir.github.io': 'site', 'qiwsir': 'name'}

```
**内建函数`enumerate`**

```
>>> week = ['monday', 'sunday', 'friday']
>>> for i in range(len(week)):
...     print week[i]+' is '+str(i)     #注意，i是int类型，如果和前面的用+连接，必须是str类型
...                                                           #如果使用Python 3，请自行更换为print(week[i]+' is '+str(i))
monday is 0
sunday is 1
friday is 2

```

内建函数enumerate，能够实现类似的功能，并且简化。

```
>>> for (i, day) in enumerate(week):
...     print day+' is '+str(i)        #Python 3: print(day+' is '+str(i))
... 
monday is 0
sunday is 1
friday is 2

```

```
>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]

>>> list(enumerate(seasons, start=1))
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]

```

**神奇的List comprehensions**

```
>>> squares = [x**2 for x in range(1, 10)]
>>> squares
[1, 4, 9, 16, 25, 36, 49, 64, 81]

>>> mybag = [' glass',' apple','green leaf ']   #有的前面有空格，有的后面有空格
>>> [one.strip() for one in mybag]              #去掉元素前后的空格
['glass', 'apple', 'green leaf']

```

```
>>> week = ['monday', 'sunday', 'friday']
>>>[day+' is ' + str(i) for i,day in enumerate(week)]
>>>['monday is 0', 'sunday is 1', 'friday is 2']

```

----------------

# Day 4

---


**while...else**

`while...else` 有点类似 `if ... else` ，只需要一个例子就可以理解。 当然，一遇到 else 了，就意味着已经不在while循环内了。

```
count = 0
while count < 5:
    print count, " is  less than 5"
    count = count + 1
else:
    print count, " is not less than 5"
```

**for...else**

除了有 `while...else` 外，还可以有 `for...else` 。这个循环也通常用在当跳出循环之后要做的事情。

```
# coding=utf-8

from math import sqrt

for n in range(99, 1, -1):
    root = sqrt(n)
    if root == int(root):
        print n
        break

else:
    print "Nothing."
```

## 文件

### 读文件

```
>>> f = open("130.txt")     #打开已经存在的文件
>>> for line in f:
...     print line        #Python 3: print(line)
... 
learn python

http://qiwsir.github.io

qiwsir@gmail.com

```
**声明**：文件130.txt必须在当前目录下，否则需要引用相对路径

在原文中，每行结束有本行结束符号 \n ，表示换行。 print line 或者 print(line) 默认情况下，打印完 line 的对象之后会增加一个 \n 。这样看来，在每行末尾就有两个 \n ，即： \n\n ，于是在打印中就出现了一个空行。print 后面加个`,`就可以去掉空格

```
>>> f = open('130.txt')
>>> for line in f:
...     print line,        #Python 3: print(line, end='')
... 
learn python
http://qiwsir.github.io
qiwsir@gmail.com

```
**创建文件**

```
>>> nf = open("131.txt", "w") # w表示以写方式打开文件，可向文件写入信息。如文件存在，则清空该文件，再写入新内容
>>> nf.write("This is a file")
>>> nf.close() #记得每次写完之后都要关闭文件

```

在对文件进行写入操作之后，一定要牢记一个事情： `file.close()` ，这个操作千万不要忘记

有另外一种方法，能够不用这么让人揪心，实现安全地关闭文件。

```
>>> with open("130.txt","a") as f: # a表示以追加模式打开文件（即一打开文件，文件指针自动移到文件末尾），如果文件不存在则创建
...     f.write("\nThis is about 'with...as...'")
... 
>>> with open("130.txt","r") as f:
...     print f.read()
... 
learn python
http://qiwsir.github.io
qiwsir@gmail.com
hello

This is about 'with...as...'
>>> 

```
用 open() 操作文件，可以有不同的模式。

模式  |描述
-------  |------------
r|以读方式打开文件，可读取文件信息。
w|以写方式打开文件，可向文件写入信息。如文件存在，则清空该文件，再写入新内容
a|以追加模式打开文件（即一打开文件，文件指针自动移到文件末尾），如果文件不存在则创建
r+| 以读写方式打开文件，可对文件进行读和写操作。 
w+ |消除文件内容，然后以读写方式打开文件。 
a+ |以读写方式打开文件，并把文件指针移到文件尾。 
b |以二进制模式打开文件，而不是以文本模式。该模式只对Windows或Dos有效，类Unix的文件是用二进制模式进行操作的。 


### 文件的状态

```
>>> import os
>>> file_stat = os.stat("131.txt")      #查看这个文件的状态
>>> file_stat                           #文件状态是这样的。从下面的内容，有不少从英文单词中可以猜测出来。
posix.stat_result(st_mode=33204, st_ino=5772566L, st_dev=2049L, st_nlink=1, st_uid=1000, st_gid=1000, st_size=69L, st_atime=1407897031, st_mtime=1407734600, st_ctime=1407734600)

>>> file_stat.st_ctime                  #这个是文件创建时间
1407734600.0882277      

```
这是什么时间？看不懂！别着急，换一种方式。在Python中，有一个模块 time ，是专门针对时间设计的。

```
>>> import time                         
>>> time.localtime(file_stat.st_ctime)  #这回看清楚了。
time.struct_time(tm_year=2014, tm_mon=8, tm_mday=11, tm_hour=13, tm_min=23, tm_sec=20, tm_wday=0, tm_yday=223, tm_isdst=0)

```

### read/readline/readlines

read 全部读取

```
>>> f = open("you.md")
>>> content = f.read()
>>> content
'You Raise Me Up\nWhen I am down and, oh my soul, so weary;\nWhen troubles come and my heart burdened be;\nThen, I am still and wait here in the silence,\nUntil you come and sit awhile with me.\nYou raise me up, so I can stand on mountains;\nYou raise me up, to walk on stormy seas;\nI am strong, when I am on your shoulders;\nYou raise me up: To more than I can be.\n'
>>> f.close()

```

readline每次读取一行

```
>>> f = open("you.md")
>>> f.readline()
'You Raise Me Up\n'
>>> f.readline()
'When I am down and, oh my soul, so weary;\n'
>>> f.readline()
'When troubles come and my heart burdened be;\n'
>>> f.close()

```
可以用循环语句来完成对全文的读取。

```
# coding=utf-8

f = open("you.md")

while True:
    line = f.readline()
    if not line:         #到EOF，返回空字符串，则终止循环
        break
    print line ,         #Python 3: print(line, end='')

f.close()                #别忘记关闭文件

```

readlines() 把文件读取为一个列表，列表的每个元素都是一个字符串，每个字符串中的内容就是文件的一行文字，含行末的符号

```
>>> f = open("you.md")
>>> content = f.readlines()
>>> content
['You Raise Me Up\n', 'When I am down and, oh my soul, so weary;\n', 'When troubles come and my heart burdened be;\n', 'Then, I am still ...]

```

```
>>> for line in content:
...     print line ,         #Python 3: print(line, end='')
... 
You Raise Me Up
When I am down and, oh my soul, so weary;
When troubles come and my heart burdened be;
Then, I am still and wait here in the silence,
Until you come and sit awhile with me.
You raise me up, so I can stand on mountains;
You raise me up, to walk on stormy seas;
I am strong, when I am on your shoulders;
You raise me up: To more than I can be.
>>> f.close()

```

### 读很大的文件 :fileinput 模块

```
>>> import fileinput
>>> for line in fileinpyt.input('you.md'):
>>> 	print line,


```

readline读取之后，指针对到行末，可以用file.seek(size)来重新定位指针，file.tell()让python告诉指针当前的位置。

```
# seek(offset[, whence])
f=open('you.md')
f.readline()
Out[117]: 'You Raise Me Up\n'

f.seek(4) # whence默认为0，此时指针从开头开始偏移
f.readline()
Out[120]: 'Raise Me Up\n'

f.seek(-5,1) # 当whence为1时，指针东当前位置开始偏移，offset为负则向前偏移，为正则向后偏移
f.readline()
Out[123]: ' Up\n'

f.seek(5,2) # whence=2时，指针从文件末尾开始偏移
f.tell()
Out[125]: 370L
```
## 迭代

- 循环（loop），指的是在满足条件的情况下，重复执行同一段代码。比如，while语句。
- 迭代（iterate），指的是按照某种顺序逐个访问列表中的每一项。比如，for语句。
- 递归（recursion），指的是一个函数不断调用自身的行为。比如，以编程方式输出著名的斐波纳契数列。
- 遍历（traversal），指的是按照一定的规则访问树形结构中的每个节点，而且每个节点都只访问一次。

iter

```
>>> lst = ['q', 'i', 'w', 's', 'i', 'r']
>>> lst_iter = iter(lst)               
>>> while True:
...     print lst_iter.next()        #Python 3: print(lst_iter.__next__())
... 
q                                      
i
w
s
i
r
Traceback (most recent call last):      #读取到最后一个之后，停止循环
  File "<stdin>", line 2, in <module>
StopIteration

```

## 检查python对象

**名称**

```
>>> dir.__name__       #dir()的名字
'dir'

```

**类型**

```
>>> import types
>>> print types.__doc__
Define names for all type symbols known in the standard interpreter.

Types that are part of optional modules (e.g. array) are not listed.

>>> dir(types)
['BooleanType', 'BufferType', 'BuiltinFunctionType', 'BuiltinMethodType', 'ClassType', 'CodeType', 'ComplexType', 'DictProxyType', 'DictType', 'DictionaryType', 'EllipsisType', 'FileType', 'FloatType', 'FrameType', 'FunctionType', 'GeneratorType', 'GetSetDescriptorType', 'InstanceType', 'IntType', 'LambdaType', 'ListType', 'LongType', 'MemberDescriptorType', 'MethodType', 'ModuleType', 'NoneType', 'NotImplementedType', 'ObjectType', 'SliceType', 'StringType', 'StringTypes', 'TracebackType', 'TupleType', 'TypeType', 'UnboundMethodType', 'UnicodeType', 'XRangeType', '__builtins__', '__doc__', '__file__', '__name__', '__package__']
>>> p = "I love Python"
>>> type(p)
<type 'str'>
>>> if type(p) is types.StringType:
...     print "p is a string"
... 
p is a string


```

**属性**
有时我们只想测试一个或多个属性是否存在。如果对象具有我们正在考虑的属性，那么通常希望只检索该属性。这个任务可以由 hasattr() 和 getattr() 函数来完成.

```
>>> hasattr(id, '__doc__')
True

>>> print getattr(id, '__doc__')
id(object) -> integer

```
**可调用**

```
>>> callable("a string")
False
>>> callable(dir)
True

```
**实例**

```
>>> print isinstance.__doc__
isinstance(object, class-or-type-or-tuple) -> bool

Return whether an object is an instance of a class or of a subclass thereof.
With a type as second argument, return whether that is the object's type.
The form using a tuple, isinstance(x, (A, B, ...)), is a shortcut for
isinstance(x, A) or isinstance(x, B) or ... (etc.).
>>> isinstance(42, str)
False
>>> isinstance("python", str)
True

```

**子类**

在类这一级别，可以根据一个类来定义另一个类，同样地，这个新类会按照层次化的方式继承属性。Python 
甚至支持多重继承，多重继承意味着可以用多个父类来定义一个类，这个新类继承了多个父类。 issubclass() 
函数使我们可以查看一个类是不是继承了另一个类：

```
>>> print issubclass.__doc__
issubclass(C, B) -> Boolean
Return whether class C is a subclass (i.e., a derived class) of class B.
>>> class SuperHero(Person):   # SuperHero inherits from Person...
...     def intro(self):       # but with a new SuperHero intro
...         """Return an introduction."""
...         return "Hello, I'm SuperHero %s and I'm %s." % (self.name, self.age)
...
>>> issubclass(SuperHero, Person)
1
>>> issubclass(Person, SuperHero)
0

```

### python文档

1.文档是一种对软件系统的书面描述； 2.文档应当精确地描述软件系统； 3.软件文档是软件工程师之间用作沟通交流的一种方式； 4.文档的类型有很多种，包括软件需求文档，设计文档，测试文档，用户手册等； 5.文档的呈现方式有很多种，可以是传统的书面文字形式或图表形式，也可是动态的网页形式

[python 2.7 官方文档](https://docs.python.org/2/)

第二章语句和文件到此结束，下一节开启新的一章：函数

----------------

# 函数

## 定义函数

```
#coding:utf-8

def add_function(a, b):
    c = a + b
    return c

if __name__ == "__main__":
    result = add_function(2, 3)
    print result               #python3: print(result)

5    
```

**定义函数的格式：**

```
def 函数名(参数1，参数2，...，参数n)：

    函数体（语句块）

```
**几点说明：**

- 函数名的命名规则要符合Python中的命名要求。一般用小写字母和单下划线、数字等组合，有人习惯用aaBb的样式，但我不推荐
- def是定义函数的关键词，这个简写来自英文单词define
- 函数名后面是圆括号，括号里面，可以有参数列表，也可以没有参数
- 千万不要忘记了括号后面的冒号
- 函数体（语句块），相对于def缩进，按照python习惯，缩进四个空格

```
>>> def add(x,y):       #定义一个非常简单的函数
...     return x+y      #缩进4个空格
... 
>>> add(2,3)            #通过函数，计算2+3
5

```
 在函数`add(x,y)`中， x 、 y 并没有严格规定其所引用的对象类型。**Python中为对象编写接口，而不是为数据类型。**

### 关于命名

Python对命名的一般要求

- 文件名:全小写,可使用下划线

-  函数名:小写，可以用下划线风格单词以增加可读性。如：myfunction，my_example_function。注意：混合大小写仅被允许用于这种风格已经占据优势的时候，以便保持向后兼容。有的人，喜欢用这样的命名风格：myFunction，除了第一个单词首字母外，后面的单词首字母大写。这也是可以的，因为在某些语言中就习惯如此。但我不提倡，这是我非常鲜明的观点。


- 函数的参数：命名方式同变量（本质上就是变量）。如果一个参数名称和Python保留的关键字冲突，通常使用一个后缀下划线会好于使用缩写或奇怪的拼写。


- 变量:变量名全部小写，由下划线连接各个单词。如color = WHITE，this_is_a_variable = 1。

[python命名的官方要求](http://legacy.python.org/dev/peps/pep-0008/#prescriptive-naming-conventions)

### 调用函数

下面的若干条，是常见编写代码的注意事项：

1.别忘了冒号。一定要记住复合语句首行末尾输入“：”（if,while,for等的第一行）

2.从第一行开始。要确定顶层（无嵌套）程序代码从第一行开始。

3.空白行在交互模式提示符下很重要。模块文件中符合语句内的空白行常被忽视。但是，当你在交互模式提示符下输入代码时，空白行则是会结束语句。

4.缩进要一致。避免在块缩进中混合制表符和空格。

5.使用简洁的for循环，而不是while or range.相比，for循环更易写，运行起来也更快

6.要注意赋值语句中的可变对象。

7.不要期待在原处修改的函数会返回结果,比如list.append()，这在可修改的对象中特别注意

8.调用函数是，函数名后面一定要跟随着括号，有时候括号里面就是空空的，有时候里面放参数。

9.不要在导入和重载中使用扩展名或路径。


```
>>> def my_fun():
...     print "I am coding."        #Python 3的用户请修改为print()
...     return
...     print "I finished."
... 
>>> my_fun()
I am coding.

```
`return` 在这里就有了一个作用，结束正在执行的函数，并离开函数体返回到调用位置，有点类似循环中的 `break` 的作用。


### 参数收集

世界是不确定的，那么函数参数的个数，也当然有不确定的时候，怎么解决这个问题呢？Python用这样的方式解决参数个数的不确定性。

```
def func(x, *arg):
    print x         #Python 3请自动修改为print()的格式，下同，从略。
    result = x
    print arg       #输出通过*arg方式得到的值
    for i in arg:
        result +=i
    return result

print func(1, 2, 3, 4, 5, 6, 7, 8, 9)    #赋给函数的参数个数不仅仅是2个
# 运行后得到
1                       #这是函数体内的第一个print，参数x得到的值是1
(2, 3, 4, 5, 6, 7, 8, 9) #这是函数内的第二个print，参数arg得到的是一个元组
45                      #最后的计算结果

```
从上面例子可以看出，如果输入的参数个数不确定，其它参数全部通过 `*arg` ，以元组的形式由arg收集起来

不给那个 `*args` 传值，也是许可的。例如：

```
>>> def foo(x, *args):
...     print "x:",x                  #Python 3: print("x:"+str(x))
...     print "tuple:",args
... 
>>> foo(7)
x: 7
tuple: ()

```
这时候 `*args` 收集到的是一个空的元组。

除了用 *args 这种形式的参数接收多个值之外，还可以用**kargs的形式接收数值，不过这次有点不一样：

```
>>> def foo(**kargs):
...     print kargs        #Python 3:  print(kargs)
...
>>> foo(a=1,b=2,c=3)    #注意观察这次赋值的方式和打印的结果
{'a': 1, 'c': 3, 'b': 2}

```
如果用 `**kargs` 的形式收集值，会得到dict类型的数据，但是，需要在传值的时候说明“键”和“值”，因为在字典中是以键值对形式出现的。

综合上面的，我们就可以应付各种各样的参数

```
>>> def foo(x,y,z,*args,**kargs):
...     print x       #Python 3用户请修改为print()格式，下同
...     print y
...     print z
...     print args
...     print kargs        
... 
>>> foo('qiwsir',2,"python")
qiwsir
2
python
()
{}
>>> foo(1,2,3,4,5)
1
2
3
(4, 5)
{}
>>> foo(1,2,3,4,5,name="qiwsir")
1
2
3
(4, 5)
{'name': 'qiwsir'}

```

### 一种优雅的姿势

```
>>> def add(x, y):
...     return x + y
... 
#例子
>>> add(2, 3)
5
#或者用以下方式
>>>bar=(2,3)
>>>add(*bar)
5

```
这是使用一个星号 * ，是以元组形式传值，如果用 ** 的方式，是不是应该以字典的形式呢？理当如此。

```
>>> def book(author, name):
...     print "{0}is writing {1}".format (author,name)    #Python 3: print("{0}}is writing {1}".format (author,name))
... 
>>> bars = {"name":"Starter learning Python", "author":"Kivi"}
>>> book(**bars)
Kivi is writing Starter learning Python

```

### 递归

> 递归，见递归.

> 从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事。故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事。故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事。故事是什么呢？……””

递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。

斐波那契数列

```
# coding=utf-8

def fib(n):
    """
    This is Fibonacci by Recursion.
    """
    if n==0:
        return 0
    elif n==1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

if __name__ == "__main__":
    f = fib(10)
    print f    #Python 3: print(f)

```
为了明确递归的过程，下面走一个计算过程（考虑到次数不能太多，就让n=3）

1.n=3,fib(3)，自然要走 `return fib(3-1) + fib(3-2)` 分支

2.先看`fib(3-1)`,即fib(2)，也要走`else`分支，于是计算 `fib(2-1) + fib(2-2)`

3.`fib(2-1)`即fib(1)，在函数中就要走`elif`分支，返回1，即fib(2-1)=1。同理，容易得到fib(2-2)=0。将这两个值返回到上面一步。得到 `fib(3-1)=1+0=1`

4.再计算fib(3-2)，就简单了一些，返回的值是1，即fib(3-2)=1

5.最后计算第一步中的结果： `fib(3-1) + fib(3-2) = 1 + 1 = 2` ，将计算结果2作为返回值

```
# coding=utf-8

"""
the better Fibonacci
"""
meno = {0:0, 1:1}    

def fib(n):
    if not n in meno:    
        meno[n] = fib(n-1) + fib(n-2)
    return meno[n]

if __name__ == "__main__":
    f = fib(10)
    print f        #Python: print(f)

#运行结果
$ python 20402.py 
55

```

### 传递函数

```
# coding:utf-8

def convert(func, seq):
    return [func(i) for i in seq]

if __name__ == "__main__":
    myseq = (111, 3.14, -9.21)
    r = convert(str, myseq)
    print r    #Python 3: print(r)

```

```
# coding:utf-8

def convert(func, seq):
    return [func(i) for i in seq]

def num(n):
    if n%2 == 0:
        return n**n
    else:
        return n*n

if __name__ == "__main__":
    myseq = (3, 4, 5)
    r = convert(num, myseq)
    print r    #Python 3: print(r)

```

### 嵌套函数

```
#coding:utf-8

def foo():
    def bar():
        print "bar() is running"
    bar()                    #显示调用内嵌函数
    print "foo() is running"

foo()
#运行结果
bar() is running
foo() is running

```
如果单独调用`bar()`，是会报错的，因为bar()函数定义在foo()内部，只在foo()的函数体内生效

```
def foo():
    a = 1
    def bar():
        b = a + 1
        print "b=",b    #Python 3的用户请使用print()
    bar()
    print "a=",a

foo()
#output:
#b= 2
#a= 1

```
这里运行正常，但是下面的代码就会运行出错了

```
def foo():
    a = 1
    def bar():
        a = a + 1        #修改之处
        print "bar()a=",a
    bar()
    print "foo()a=",a

foo()

```
原因在于bar()里面用到了变量a，按照该表达式，Python解析器认定该变量应是在 bar() 内部建立的，而不是引用的外部对象。所以就报错了。

在Python 3中，你可以使用 nonlocal 关键词，如下演示。

```
def foo():
    a = 1
    def bar():
        nonlocal a
        a = a + 1
        print("bar()a=",a)
    bar()
    print("foo()a=",a)

foo()
#output
#bar()a= 2
#foo()a= 2

```

在编程实践中，嵌套原理可以这样使用：

```
def maker(n):
    def action(x):
        return x ** n
    return action

```
在 `maker()` 函数中， `return action` 返回的是 `action()` 函数对象。

```
f = maker(2)
print f
m = f(3)
print m
#运行结果
9

```
f 所引用的对象是一个函数对象—— action() 函数对象， print f 就是打印这个函数对象的信息。

## 初识装饰器

函数——是对象——能够被传递，也能够嵌套。重复一个简单的举例

```
def foo(fun):
    def wrap():
        print "start"        #Python 3用户请自行更换为print()，下同，从略
        fun()
        print "end"
        print fun.__name__
    return wrap    

def bar():
    print "I am in bar()"

```

```
f = foo(bar)
f()
#运行结果
start
I am in bar()
end
bar

```
这就是向 foo() 传递了函数对象 bar ——你已经熟悉的传递函数。对于这个问题，我们可以换一个写法——仅仅是换一个写法。

```
def foo(fun):
    def wrap():
        print "start"
        fun()
        print "end"
        print fun.__name__
    return wrap

@foo                  #增加的内容
def bar():
    print "I am in bar()"

```

@foo 是一个看起来很奇怪的东西，人们常常把类似这种东西叫做语法糖。

> 语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种
> 对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。（源自《维基
> 百科》）

如果用上面的方式，我们可以这样执行程序：

```
>>> bar()
#运行结果
start
I am in bar()
end
bar

```
以上，就是所谓的装饰器及其应用， `foo()` 是装饰器函数，使用 `@foo` 来装饰 `bar()` 函数。

装饰器本身是一个函数，将被装饰的类（后面会介绍这种东西）或者函数当作参数传递给装饰器函数，如上面所演示的那样。

### 什么是闭包

闭包是一个函数，并且这个函数具有以下特点：

- 定义在另外一个函数里面（嵌套函数）

- 引用其所在函数环境的自由变量

``
# coding:utf-8

def parabola(a, b, c):
    def para(x):
        return a*x**2 + b*x + c
    return para

p = parabola(2, 3, 4)
print p(5)        #Python 3: print(p(5))

```

------------------

Day 5

-------------

### 几个特殊函数

**lambda**

```
>>> numbers = range(10)
>>> lam = lambda x:x+3
>>> n2 = []
>>> for i in numbers:
...     n2.append(lam(i))
... 
>>> n2
[3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

```
lambda函数使用方法

```
lambda arg1, arg2, ...argN : expression using arguments

```

**map**

```
>>> items = [1,2,3,4,5]
>>> squared = []
>>> for i in items:
...     squared.append(i**2)
... 
>>> squared
[1, 4, 9, 16, 25]

>>> def sqr(x): return x**2
... 
>>> map(sqr,items)
[1, 4, 9, 16, 25]

>>> map(lambda x: x**2, items)
[1, 4, 9, 16, 25]

>>> [ x**2 for x in items ]     #这个我最喜欢了，一般情况下速度足够快，而且可读性强
[1, 4, 9, 16, 25]

```
map的参数还可以是多个

```
>>> lst1 = [1, 2, 3, 4, 5]
>>> lst2 = [6, 7, 8, 9, 0]
>>> lst3 = [7, 8, 9, 2, 1]
>>> map(lambda x,y,z: x+y+z, lst1, lst2, lst3)
[14, 17, 20, 15, 6]

```

**reduce**

```
>>> reduce(lambda x,y: x+y,[1, 2, 3, 4, 5])
15

```
对比map

```
>>> list1 = [1,2,3,4,5,6,7,8,9]
>>> list2 = [9,8,7,6,5,4,3,2,1]
>>> map(lambda x,y: x+y, list1,list2)
[10, 10, 10, 10, 10, 10, 10, 10, 10]

```
练习：有两个list， a = [3,9,8,5,2] ， b=[1,4,9,2,6] ，计算：a[0]b[0]+a[1]b[1]+...的结果。

```
>>> a = [3, 9, 8, 5, 2]
>>> b = [1, 4, 9, 2, 6]

>>> zip(a,b)        #复习一下zip，下面的方法中要用到
[(3, 1), (9, 4), (8, 9), (5, 2), (2, 6)]

>>> sum(x*y for x,y in zip(a,b))    #解析后直接求和
133

>>> new_list = [x*y for x,y in zip(a,b)]

>>> #这样也可以：new_tuple = (x*y for x,y in zip(a,b))，与上面的区别，后续会讲到
>>> new_list
[3, 36, 72, 10, 12]
>>> sum(new_list)     #或者:sum(new_tuple)
133

>>> reduce(lambda sum,(x,y): sum+x*y,zip(a,b),0)    #这个方法是在耍酷呢吗？
133

>>> from operator import add, mul            #耍酷的方法也不止一个
>>> reduce(add, map(mul, a, b))
133

>>> reduce(lambda x,y: x+y, map(lambda x,y: x*y, a,b))  #map,reduce,lambda都齐全了，更酷吗？
133

```

**filter**

```
>>> numbers = range(-5,5)
>>> numbers
[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]

>>> filter(lambda x: x>0, numbers) 
[1, 2, 3, 4]

>>> [x for x in numbers if x>0]     #与上面那句等效
[1, 2, 3, 4]

>>> filter(lambda c: c!='y', 'lucky')  #能不能对应上面文档说明那句话呢？
'luck'                                  #“If iterable is a string or a tuple, the result also has that type;”

```

编写函数，在开发实践中是非常必要和常见的，一般情况，你写的函数应该是：

1.尽量不要使用全局变量。

2.如果参数是可变类型数据，在函数内，不要修改它。

3.每个函数的功能和目标要单纯，不要试图一个函数做很多事情。

4.函数的代码行数尽量少。

5.函数的独立性越强越好，不要跟其它的外部东西产生关联。


## zip()补充


## 命名空间


**全局变量和局部变量**

```
x = 2

def funcx():
    x = 9
    print "this x is in the funcx:-->", x        #Python 3请自动修改为print()，下同，从略

funcx()
print "--------------------------"
print "this x is out of funcx:-->", x
#运行结果
this x is in the funcx:--> 9
--------------------------
this x is out of funcx:--> 2

```

```
x = 2
def funcx():
    global x    #跟上面函数的不同之处
    x = 9
    print "this x is in the funcx:-->",x

funcx()
print "--------------------------"
print "this x is out of funcx:-->",x
#运行结果
this x is in the funcx:--> 9
--------------------------
this x is out of funcx:--> 9

```

**作用域**

Python的作用域是怎么划分的呢？可以划分为四个层级：

1.Local：局部作用域，或称本地作用域

2.Enclosing：嵌套作用域

3.Global：全局作用域

4.Built-in：内建作用域

```
#coding:utf-8

def outer_foo():
    a = 10
    def inner_foo():
        a = 20
        print "inner_foo,a=", a      #a=20
                                                           #Python 3的读者，请自行修改为print()函数形式，下同，从略
    inner_foo()
    print "outer_foo,a=", a          #a=10

a = 30
outer_foo()
print "a=", a                #a=30

#运行结果
inner_foo,a= 20
outer_foo,a= 10
a= 30

```

**命名空间**

命名空间是从所定义的命名到对象的映射集合。

不同的命名空间，可以同时存在，当彼此相互独立互不干扰。

命名空间因为对象的不同，也有所区别，可以分为如下几种：

1.本地命名空间(Function&Class: Local Namespaces)
：模块中有函数或者类，每个函数或者类所定义的命名空间就是本地命名空间。如果函数返回了结果或者抛出异常，则本地命名空间也结束了。

2.全局命名空间(Module:Global Namespaces)：每个模块创建它自己所拥有的全局命名空间，不同模块的全局命名空间彼此独立，不同模块中
相同名称的命名空间，也会因为模块的不同而不相互干扰。

3.内置命名空间(Built-in Namespaces)：Python运行起来，它们就存在了。内置函数的命名空间都属于内置命名空间，所以，我们可以在任何
程序中直接运行它们，比如前面的id(),不需要做什么操作，拿过来就直接使用了。

那么程序在查询上述三种命名空间的时候，就按照从里到外的顺序，即：**Local Namespaces --> Global Namesspaces --> Built-in Namesspaces**

```
>>> def foo(num,str):
...     name = "qiwsir"
...     print locals()
... 
>>> foo(221,"qiwsir.github.io")
{'num': 221, 'name': 'qiwsir', 'str': 'qiwsir.github.io'}
>>> 

```
关于函数的学习暂时告一段落，接下来将迎接新的篇章，进阶篇，下一节：类

-------------------





